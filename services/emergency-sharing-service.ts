import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';
import QRCode from 'qrcode';

export interface SharingMethod {
  id: string;
  type: 'email' | 'sms' | 'qr' | 'print' | 'link';
  enabled: boolean;
  config?: Record<string, any>;
}

export interface SharingTemplate {
  id: string;
  name: string;
  type: 'email' | 'sms' | 'print';
  subject?: string;
  content: string;
  variables: string[]; // Available template variables
}

export interface SharingRecord {
  id: string;
  tokenId: string;
  contactId: string;
  method: 'email' | 'sms' | 'qr' | 'print' | 'link';
  recipient: string;
  timestamp: string;
  status: 'pending' | 'sent' | 'delivered' | 'failed';
  error?: string;
  metadata?: Record<string, any>;
}

export interface ShareTokenRequest {
  tokenId: string;
  contactId: string;
  methods: Array<{
    type: 'email' | 'sms' | 'qr' | 'print' | 'link';
    recipient?: string;
    templateId?: string;
    customMessage?: string;
  }>;
  urgencyLevel: 'normal' | 'urgent' | 'critical';
  includeInstructions: boolean;
}

export class EmergencySharingService {
  private dataDir: string;
  private defaultTemplates: SharingTemplate[] = [
    {
      id: 'email-standard',
      name: 'Standard Email',
      type: 'email',
      subject: 'Emergency Access: {{contact_name}} - {{urgency}}',
      content: `Dear {{contact_name}},

You have been granted emergency access to important information.

Access Details:
- Access URL: {{access_url}}
- Expires: {{expires_at}}
- Maximum Uses: {{max_uses}}
- Access Level: {{access_level}}

{{#if custom_message}}
Personal Message:
{{custom_message}}
{{/if}}

IMPORTANT INSTRUCTIONS:
1. This link is confidential and personal to you
2. Access will expire automatically on {{expires_at}}
3. Do not share this link with others
4. All access attempts are logged for security

If you need help or have questions, please contact the sender of this email.

Best regards,
Emergency Access System`,
      variables: ['contact_name', 'access_url', 'expires_at', 'max_uses', 'access_level', 'custom_message', 'urgency']
    },
    {
      id: 'sms-brief',
      name: 'Brief SMS',
      type: 'sms',
      content: 'Emergency Access Link: {{access_url}} - Expires {{expires_short}}. Keep confidential. From: {{sender_name}}',
      variables: ['access_url', 'expires_short', 'sender_name']
    },
    {
      id: 'print-detailed',
      name: 'Detailed Print Instructions',
      type: 'print',
      content: `EMERGENCY ACCESS INSTRUCTIONS
=============================

Contact: {{contact_name}}
Generated: {{created_at}}
Expires: {{expires_at}}

ACCESS URL:
{{access_url}}

QR CODE:
{{qr_code}}

BACKUP ACCESS CODE:
{{backup_code}}

INSTRUCTIONS:
1. Use the URL above or scan the QR code
2. This access expires on {{expires_at}}
3. Maximum {{max_uses}} uses allowed
4. Access Level: {{access_level}}

IMPORTANT:
- Keep this document secure
- Do not share with unauthorized persons
- All access is logged for security
- Contact sender if issues arise

{{#if custom_message}}
ADDITIONAL MESSAGE:
{{custom_message}}
{{/if}}

Generated by If I'm Gone Emergency Access System`,
      variables: ['contact_name', 'created_at', 'expires_at', 'access_url', 'qr_code', 'backup_code', 'max_uses', 'access_level', 'custom_message']
    }
  ];

  constructor() {
    this.dataDir = path.join(process.cwd(), 'data', 'emergency-sharing');
  }

  private async ensureDirectories(): Promise<void> {
    await fs.mkdir(path.join(this.dataDir), { recursive: true });
    await fs.mkdir(path.join(this.dataDir, 'templates'), { recursive: true });
    await fs.mkdir(path.join(this.dataDir, 'records'), { recursive: true });
    await fs.mkdir(path.join(this.dataDir, 'qr-codes'), { recursive: true });
  }

  /**
   * Share emergency access token via specified methods
   */
  async shareToken(request: ShareTokenRequest): Promise<{
    success: boolean;
    sharingRecords: SharingRecord[];
    errors: string[];
  }> {
    await this.ensureDirectories();

    const results = {
      success: true,
      sharingRecords: [] as SharingRecord[],
      errors: [] as string[]
    };

    // Get token data (we need to load it directly since it's private in the service)
    const tokenData = await this.loadTokenData(request.tokenId);
    if (!tokenData) {
      throw new Error('Token not found');
    }

    // Get contact data
    const { emergencyAccessService } = await import('./emergency-access-service');
    const contact = await emergencyAccessService.getContact(request.contactId);
    if (!contact) {
      throw new Error('Contact not found');
    }

    // Generate sharing data
    const accessUrl = this.generateAccessUrl(request.tokenId);
    const sharingData = {
      contact_name: contact.name,
      contact_email: contact.email,
      access_url: accessUrl,
      expires_at: new Date(tokenData.expiresAt).toLocaleDateString(),
      expires_short: this.formatShortDate(tokenData.expiresAt),
      max_uses: tokenData.maxUses.toString(),
      access_level: tokenData.accessLevel,
      created_at: new Date().toLocaleDateString(),
      urgency: request.urgencyLevel.toUpperCase(),
      sender_name: 'Emergency Access System'
    };

    // Process each sharing method
    for (const method of request.methods) {
      try {
        const record = await this.processSharing(
          request.tokenId,
          request.contactId,
          method,
          sharingData,
          request.includeInstructions
        );
        results.sharingRecords.push(record);

        if (record.status === 'failed') {
          results.success = false;
          results.errors.push(`${method.type}: ${record.error}`);
        }
      } catch (error) {
        results.success = false;
        results.errors.push(`${method.type}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return results;
  }

  /**
   * Process individual sharing method
   */
  private async processSharing(
    tokenId: string,
    contactId: string,
    method: ShareTokenRequest['methods'][0],
    sharingData: Record<string, string>,
    includeInstructions: boolean
  ): Promise<SharingRecord> {
    const recordId = crypto.randomUUID();
    const timestamp = new Date().toISOString();

    const record: SharingRecord = {
      id: recordId,
      tokenId,
      contactId,
      method: method.type,
      recipient: method.recipient || '',
      timestamp,
      status: 'pending'
    };

    try {
      switch (method.type) {
        case 'email':
          await this.shareViaEmail(method, sharingData, includeInstructions);
          record.status = 'sent';
          break;

        case 'sms':
          await this.shareViaSMS(method, sharingData);
          record.status = 'sent';
          break;

        case 'qr':
          const qrPath = await this.generateQRCode(sharingData.access_url, tokenId);
          record.status = 'sent';
          record.metadata = { qrCodePath: qrPath };
          break;

        case 'print':
          const printContent = await this.generatePrintContent(method, sharingData);
          record.status = 'sent';
          record.metadata = { printContent };
          break;

        case 'link':
          // For direct link sharing, just mark as sent
          record.status = 'sent';
          record.metadata = { accessUrl: sharingData.access_url };
          break;

        default:
          throw new Error(`Unsupported sharing method: ${method.type}`);
      }
    } catch (error) {
      record.status = 'failed';
      record.error = error instanceof Error ? error.message : 'Unknown error';
    }

    // Save sharing record
    await this.saveSharingRecord(record);

    // Log sharing event for audit trail
    await this.logSharingEvent(record, method);

    return record;
  }

  /**
   * Share via email using nodemailer
   */
  private async shareViaEmail(
    method: ShareTokenRequest['methods'][0],
    sharingData: Record<string, string>,
    includeInstructions: boolean
  ): Promise<void> {
    // Get template
    const template = await this.getTemplate(method.templateId || 'email-standard');
    if (!template) {
      throw new Error('Email template not found');
    }

    // Add custom message if provided
    if (method.customMessage) {
      sharingData.custom_message = method.customMessage;
    }

    // Render template
    const subject = this.renderTemplate(template.subject || '', sharingData);
    const content = this.renderTemplate(template.content, sharingData);

    // Validate recipient
    if (!method.recipient || !this.isValidEmail(method.recipient)) {
      throw new Error('Invalid email recipient');
    }

    // Send email using email service
    const { emailService } = await import('./email-service');
    const result = await emailService.sendEmergencyAccessEmail(
      method.recipient,
      subject,
      content
    );

    if (!result.success) {
      throw new Error(`Failed to send email: ${result.error}`);
    }

    console.log(`[EMAIL SENT] To: ${method.recipient}, MessageID: ${result.messageId}`);
  }

  /**
   * Share via SMS (placeholder - would integrate with SMS service)
   */
  private async shareViaSMS(
    method: ShareTokenRequest['methods'][0],
    sharingData: Record<string, string>
  ): Promise<void> {
    // Get template
    const template = await this.getTemplate(method.templateId || 'sms-brief');
    if (!template) {
      throw new Error('SMS template not found');
    }

    // Add custom message if provided
    if (method.customMessage) {
      sharingData.custom_message = method.customMessage;
    }

    // Render template
    const content = this.renderTemplate(template.content, sharingData);

    // In a real implementation, you would send the SMS here
    // For now, we just log it (in production, integrate with Twilio, AWS SNS, etc.)
    console.log(`[SMS SHARING] To: ${method.recipient}`);
    console.log(`[SMS SHARING] Content: ${content}`);

    // Simulate SMS sending
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  /**
   * Generate QR code for access URL
   */
  private async generateQRCode(accessUrl: string, tokenId: string): Promise<string> {
    try {
      const qrCodeData = await QRCode.toDataURL(accessUrl, {
        width: 400,
        margin: 2,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        }
      });

      const fileName = `qr-${tokenId}-${Date.now()}.png`;
      const filePath = path.join(this.dataDir, 'qr-codes', fileName);
      
      // Extract base64 data and save as file
      const base64Data = qrCodeData.replace(/^data:image\/png;base64,/, '');
      await fs.writeFile(filePath, base64Data, 'base64');

      return filePath;
    } catch (error) {
      throw new Error(`Failed to generate QR code: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Generate print content
   */
  private async generatePrintContent(
    method: ShareTokenRequest['methods'][0],
    sharingData: Record<string, string>
  ): Promise<string> {
    // Get template
    const template = await this.getTemplate(method.templateId || 'print-detailed');
    if (!template) {
      throw new Error('Print template not found');
    }

    // Generate QR code for print version
    const qrCodePath = await this.generateQRCode(sharingData.access_url, 'print');
    sharingData.qr_code = `[QR Code saved at: ${qrCodePath}]`;
    
    // Generate backup access code (simplified version of URL)
    sharingData.backup_code = this.generateBackupCode(sharingData.access_url);

    // Add custom message if provided
    if (method.customMessage) {
      sharingData.custom_message = method.customMessage;
    }

    // Render template
    return this.renderTemplate(template.content, sharingData);
  }

  /**
   * Get sharing template
   */
  private async getTemplate(templateId: string): Promise<SharingTemplate | null> {
    // First check custom templates
    try {
      const templatePath = path.join(this.dataDir, 'templates', `${templateId}.json`);
      const data = await fs.readFile(templatePath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      // Fall back to default templates
      return this.defaultTemplates.find(t => t.id === templateId) || null;
    }
  }

  /**
   * Render template with data
   */
  private renderTemplate(template: string, data: Record<string, string>): string {
    let rendered = template;

    // Simple template rendering (in production, use a proper template engine)
    Object.entries(data).forEach(([key, value]) => {
      const regex = new RegExp(`{{${key}}}`, 'g');
      rendered = rendered.replace(regex, value || '');
    });

    // Handle conditional blocks (simplified)
    rendered = rendered.replace(/{{#if\s+(\w+)}}([\s\S]*?){{\/if}}/g, (match, condition, content) => {
      return data[condition] ? content : '';
    });

    return rendered;
  }

  /**
   * Generate backup access code
   */
  private generateBackupCode(accessUrl: string): string {
    // Extract token from URL and create a shorter reference code
    const urlParts = accessUrl.split('/');
    const token = urlParts[urlParts.length - 1];
    
    // Create a shorter code from the token
    const hash = crypto.createHash('sha256').update(token).digest('hex');
    return hash.substring(0, 12).toUpperCase().match(/.{1,4}/g)?.join('-') || 'INVALID';
  }

  /**
   * Format short date
   */
  private formatShortDate(dateString: string): string {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, { 
      month: 'short', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  /**
   * Validate email address
   */
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Generate access URL
   */
  private generateAccessUrl(tokenId: string): string {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    return `${baseUrl}/emergency-access/${tokenId}`;
  }

  /**
   * Load token data
   */
  private async loadTokenData(tokenId: string): Promise<any> {
    try {
      const tokenPath = path.join(process.cwd(), 'data', 'emergency-access', 'tokens', `${tokenId}.json`);
      const data = await fs.readFile(tokenPath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      return null;
    }
  }

  /**
   * Save sharing record
   */
  private async saveSharingRecord(record: SharingRecord): Promise<void> {
    const filePath = path.join(this.dataDir, 'records', `${record.id}.json`);
    await fs.writeFile(filePath, JSON.stringify(record, null, 2), 'utf-8');
  }

  /**
   * Log sharing event to emergency access audit trail
   */
  private async logSharingEvent(
    record: SharingRecord, 
    method: ShareTokenRequest['methods'][0]
  ): Promise<void> {
    try {
      const { emergencyAccessService } = await import('./emergency-access-service');
      
      // Create audit log entry for sharing event
      const logData = {
        tokenId: record.tokenId,
        contactId: record.contactId,
        action: 'shared' as const,
        success: record.status === 'sent',
        error: record.error,
        metadata: {
          sharingMethod: record.method,
          recipient: record.recipient,
          sharingRecordId: record.id,
          templateId: method.templateId,
          customMessage: method.customMessage ? '[Custom message provided]' : undefined,
          qrCodePath: record.metadata?.qrCodePath,
          printContent: record.metadata?.printContent ? '[Print content generated]' : undefined
        }
      };

      // Use the emergency access service to log the event
      await (emergencyAccessService as any).logAccess(logData);
      
    } catch (error) {
      console.error('Failed to log sharing event:', error);
      // Don't throw error here - sharing should still succeed even if logging fails
    }
  }

  /**
   * Get sharing records
   */
  async getSharingRecords(options: {
    tokenId?: string;
    contactId?: string;
    method?: string;
    limit?: number;
  } = {}): Promise<SharingRecord[]> {
    try {
      await this.ensureDirectories();
      const files = await fs.readdir(path.join(this.dataDir, 'records'));
      
      const records = await Promise.all(
        files
          .filter(f => f.endsWith('.json'))
          .map(async f => {
            const data = await fs.readFile(path.join(this.dataDir, 'records', f), 'utf-8');
            return JSON.parse(data) as SharingRecord;
          })
      );

      let filteredRecords = records;

      if (options.tokenId) {
        filteredRecords = filteredRecords.filter(r => r.tokenId === options.tokenId);
      }
      if (options.contactId) {
        filteredRecords = filteredRecords.filter(r => r.contactId === options.contactId);
      }
      if (options.method) {
        filteredRecords = filteredRecords.filter(r => r.method === options.method);
      }

      // Sort by timestamp (newest first)
      filteredRecords.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

      // Apply limit
      if (options.limit) {
        filteredRecords = filteredRecords.slice(0, options.limit);
      }

      return filteredRecords;
    } catch (error) {
      return [];
    }
  }

  /**
   * Get sharing statistics
   */
  async getSharingStats(): Promise<{
    totalShares: number;
    sharesByMethod: Record<string, number>;
    sharesByStatus: Record<string, number>;
    recentShares: number;
  }> {
    const records = await this.getSharingRecords();
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);

    const sharesByMethod: Record<string, number> = {};
    const sharesByStatus: Record<string, number> = {};
    let recentShares = 0;

    records.forEach(record => {
      // Count by method
      sharesByMethod[record.method] = (sharesByMethod[record.method] || 0) + 1;
      
      // Count by status
      sharesByStatus[record.status] = (sharesByStatus[record.status] || 0) + 1;
      
      // Count recent shares
      if (new Date(record.timestamp) > weekAgo) {
        recentShares++;
      }
    });

    return {
      totalShares: records.length,
      sharesByMethod,
      sharesByStatus,
      recentShares
    };
  }
}

// Singleton instance
export const emergencySharingService = new EmergencySharingService();